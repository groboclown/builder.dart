/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Groboclown
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * The declarative build tool internals.
 */

library builder.src.decl;

import 'dart:io';
import 'dart:mirrors';

import '../resource.dart';
import 'target.dart';
import 'exceptions.dart';
import 'project.dart';



/**
 * Describes how a [BuildTool] connects with the resources.
 */
abstract class Pipe {
  /**
   * All inputs that are required to exist before the [BuildTool] can run.
   * These must be defined before the build runs.
   */
  List<Resource> get requiredInput;

  /**
   * All the input [Resource] that, if they are generated by another build
   * tool, will be run before the [BuildTool].
   */
  List<Resource> get optionalInput;

  /**
   * As many [Resource] that can be anticipated to be generated by the
   * tool.  Where possible, this should be all the precise resources,
   * or, if the tool generates a bunch of files whose name can't be
   * accurately predicted, then at least the directory into which they
   * will be placed.
   *
   * Multiple build tools can output into the same directory.
   */
  List<Resource> get output;

  /**
   * Any input that can be mapped directly to one or more [Resource]
   * should include a direct pipe reference to allow for more efficient
   * building.
   */
  Map<Resource, List<Resource>> get directPipe;


  factory Pipe.direct(Map<Resource, List<Resource>> direct) {
    return new SimplePipe.direct(direct);
  }


  factory Pipe.single(Resource input, Resource output) {
    return new SimplePipe.single(input, output);
  }


  factory Pipe.list(List<Resource> inputs, List<Resource> outputs) {
    return new SimplePipe.list(inputs, outputs);
  }


  factory Pipe.all({ List<Resource> requiredInput: null,
      List<Resource> optionalInput: null,
      List<Resource> output: null,
      Map<Resource, List<Resource>> directPipe: null }) {
    if (requiredInput == null) {
      requiredInput = <Resource>[];
    }
    if (optionalInput == null) {
      optionalInput = <Resource>[];
    }
    if (directPipe == null) {
      directPipe = <Resource, List<Resource>>{};
    }
    return new SimplePipe.all(requiredInput: requiredInput,
      optionalInput: optionalInput, output: output, directPipe: directPipe);
  }
}


class SimplePipe implements Pipe {
  final List<Resource> _requiredInput = <Resource>[];
  final List<Resource> _optionalInput = <Resource>[];
  final List<Resource> _output = <Resource>[];
  final Map<Resource, List<Resource>> _directPipe = <Resource, List<Resource>>{};

  SimplePipe.direct(Map<Resource, List<Resource>> direct) {
    // Ensure we don't have duplicates in the wrong places
    Set<Resource> allOut = new Set<Resource>();
    for (var r in direct.keys) {
      _requiredInput.add(r);
      Set<Resource> out = new Set<Resource>.from(direct[r]);
      _directPipe[r] = new List<Resource>.from(out);
      allOut.addAll(out);
    }
    _output.addAll(allOut);
  }


  SimplePipe.single(Resource input, Resource output) {
    if (input != null) {
      _requiredInput.add(input);
    }
    if (output != null) {
      _output.add(output);
    }
    if (input != null && output != null) {
      _directPipe[input] = <Resource>[ output ];
    }
  }


  SimplePipe.list(List<Resource> inputs, List<Resource> outputs) {
    if (inputs != null) {
      _requiredInput.addAll(new Set<Resource>.from(inputs));
    }
    if (outputs != null) {
      _output.addAll(new Set<Resource>.from(outputs));
    }
  }


  SimplePipe.all({ List<Resource> requiredInput: null,
      List<Resource> optionalInput: null,
      List<Resource> output: null,
      Map<Resource, List<Resource>> directPipe: null }) {
    if (requiredInput != null) {
      _requiredInput.addAll(new Set<Resource>.from(requiredInput));
    }
    if (optionalInput != null) {
      _optionalInput.addAll(new Set<Resource>.from(optionalInput));
    }

    var out = new Set<Resource>();
    if (output != null) {
      out.addAll(output);
    }

    if (directPipe != null) {
      for (Resource r in directPipe.keys) {
        if (! _requiredInput.contains(r) && ! _optionalInput.contains(r)) {
          _optionalInput.add(r);
        }
        _directPipe[r] = new List<Resource>.from(
            new Set<Resource>.from(directPipe[r]));
        out.addAll(_directPipe[r]);
      }
    }
    _output.addAll(out);
  }


  List<Resource> get requiredInput => _requiredInput;
  List<Resource> get optionalInput => _optionalInput;
  List<Resource> get output => _output;
  Map<Resource, List<Resource>> get directPipe => _directPipe;
}






/**
 * Top level build tool.
 */
abstract class BuildTool extends TargetMethod {
  final TargetMethod phase;
  final Pipe pipe;

  BuildTool(String name, target targetDef, String phase, Pipe pipe) :
      this.phase = _PHASES[phase],
      this.pipe = pipe,
      super(name, targetDef) {

    _addToPhase(phase, this);

    _connectPipes(this);

    _OUTPUT_TARGETS[name] = this;
  }


  /**
   * Constructs a [target] from the standard ([String]) definitions, for use
   * in passing to the [BuildTool] constructor.  It does not wire anything up
   * to the [BuildTool] instance.
   */
  static target mkTargetDef(String name, String description,
      String phase, Pipe pipe, List<String> dependencies,
      List<String> weakDependencies) {
    if (! _PHASES.containsKey(phase)) {
      throw new NoSuchPhaseException(phase);
    }
    if (_OUTPUT_TARGETS.containsKey(name) || _PHASES.containsKey(name) ||
        _TOP_PHASES.containsKey(name)) {
      throw new MultipleTargetsWithSameNameException(name);
    }

    var targetDef = new target.internal(description, dependencies,
      weakDependencies, false);
    return targetDef;
  }
}


class PhaseTarget extends TargetMethod {
  final List<String> phaseRunsBefore;
  final List<String> phaseRunsAfter;
  
  factory PhaseTarget(String name, List<String> phaseRunsBefore,
      List<String> phaseRunsAfter) {
    var targetDef = new target.internal(name,
      <String>[], phaseRunsAfter, false);
    return new PhaseTarget._(name, targetDef, phaseRunsBefore, phaseRunsAfter);
  }
  
  PhaseTarget._(String name, target targetDef, List<String> phaseRunsBefore,
      List<String> phaseRunsAfter) :
    this.phaseRunsBefore = phaseRunsBefore,
    this.phaseRunsAfter = phaseRunsAfter,
    super(name, targetDef);
  
  
  void wire(Map<String, PhaseTarget> phaseMap) {
    // only need to wire up the before, because the after was done at
    // construction time.
    for (var before in phaseRunsBefore) {
      var phase = phaseMap[before];
      if (phase == null) {
        throw new MissingTargetException(name, before);
      }
      // note: duplicates are fine, they are ignored during the
      // ordering.
      //print("--Wiring " + name + " as dependency for " + phase.name);
      if (targetDef.weakDepends.contains(phase.name)) {
        throw new Exception("added ourself when it shouldn't have");
      }
      phase.targetDef.weakDepends.add(name);
    }
  }
  
  @override
  void call(Project project) {}
}

class TopPhaseTarget extends TargetMethod {
  factory TopPhaseTarget(String name, PhaseTarget phase, bool isDefault) {
    var targetDef = new target.internal(name,
      <String>[], <String>[ phase.name ], isDefault);
    return new TopPhaseTarget._(name, targetDef);
  }

  TopPhaseTarget._(String name, target targetDef) :
    super(name, targetDef);

  @override
  void call(Project project) {}
}

class VirtualTarget extends TargetMethod {
  factory VirtualTarget(String name, String description,
      List<String> dependencies, List<String> weakDependencies) {
    if (dependencies == null) {
      dependencies = <String>[];
    }
    if (weakDependencies == null) {
      weakDependencies = <String>[];
    }
    var targetDef = new target.internal(description,
      dependencies, weakDependencies, false);
    var ret = new VirtualTarget._(name, targetDef);
    _OUTPUT_TARGETS[name] = ret;
    return ret;
  }

  VirtualTarget._(String name, target targetDef) :
    super(name, targetDef);

  @override
  void call(Project project) {}
}




final Map<String, TargetMethod> _OUTPUT_TARGETS = <String, TargetMethod>{};
final Map<String, PhaseTarget> _PHASES = <String, PhaseTarget>{};
final Map<String, TargetMethod> _TOP_PHASES = <String, TargetMethod>{};
final Map<String, String> _PHASE_NAME_TO_TOP = <String, String>{};


/**
 * NOTE: this function is heavily tied to the different data structures
 * in this file.  Updating the list of targets or phases will mean another
 * call into this function.
 */
List<TargetMethod> getTargets({ libraryName: "build" }) {
  if (_OUTPUT_TARGETS.isEmpty) {
    // Assume that all the targets are defined as top-level variables that
    // are lazy-loaded.
    for (LibraryMirror library in currentMirrorSystem().libraries.values) {
      if (MirrorSystem.getName(library.simpleName) == libraryName) {
        for (DeclarationMirror topLevel in library.declarations.values) {
          if (topLevel is VariableMirror) {
            library.getField(topLevel.simpleName);
          }
        }
      }
    }
  }
  
  if (_OUTPUT_TARGETS.isEmpty) {
    stderr.writeln("ERROR: no targets defined.  Did you remember to " +
      "put them inside the build.dart `void main(List<String> args)` " +
      "function?");
    exit(2);
  }
  
  // Wire up the phases
  for (var phase in _PHASES.values) {
    phase.wire(_PHASES);
  }
  
  var ret = new List<TargetMethod>.from(_OUTPUT_TARGETS.values);
  ret.addAll(_PHASES.values);
  ret.addAll(_TOP_PHASES.values);
  return ret;
}



void _addToPhase(String phaseName, BuildTool tool) {
  var phaseGroup = _PHASES[phaseName];
  phaseGroup.targetDef.weakDepends.add(tool.name);
  var phaseTarget = _TOP_PHASES[_PHASE_NAME_TO_TOP[phaseName]];
  phaseTarget.targetDef.strongDepends.add(tool.name);
}


bool hasDefault = false;

/**
 * Creates the weak "phase" definition target and a top-level
 * Phase target.  The top-level target is returned.
 */
TargetMethod addPhase(String phaseName, String topTargetName,
    List<String> phaseRunsBefore, List<String> phaseRunsAfter,
    { isDefault: false }) {
  if (isDefault && hasDefault) {
    throw new MultipleDefaultTargetException();
  }
  hasDefault = hasDefault || isDefault;
  
  if (_PHASES.containsKey(phaseName)) {
    throw new MultipleTargetsWithSameNameException(phaseName);
  }
  if (_TOP_PHASES.containsKey(topTargetName)) {
    throw new MultipleTargetsWithSameNameException(topTargetName);
  }
  _PHASE_NAME_TO_TOP[phaseName] = topTargetName;
  
  // Create the weak targets
  var phaseTarget = new PhaseTarget(phaseName, phaseRunsBefore, phaseRunsAfter);
  _PHASES[phaseName] = phaseTarget;
  
  // Create the top-level targets
  // - It has a weak dependency on the phase, so it will be correctly sorted
  //   that way.
  _TOP_PHASES[topTargetName] = new TopPhaseTarget(topTargetName, phaseTarget,
      isDefault);
}


final Map<Resource, List<BuildTool>> _PIPED_OUTPUT =
  <Resource, List<BuildTool>>{};
final Map<Resource, List<BuildTool>> _PIPED_INPUT =
  <Resource, List<BuildTool>>{};



void _connectPipes(BuildTool tool) {
// FIXME connect this new tool to the list of existing output targets.
// Take special care with outputs that are shared by tools.
}


List<BuildTool> forwardChain(List<Resource> changedResources) {
// FIXME construct the ordered build tools that should run if the given
// resources have changed since the last build.  This is a forward
// chain of targets based on the pipe connections that still must maintain
// the dependency graph ordering.
}

